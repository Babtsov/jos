# Lab 4 notes
lab link: https://pdos.csail.mit.edu/6.828/2017/labs/lab4/  
video explanation about APIC: https://youtu.be/rnGVincwk30?t=11m13s  

## Exercise 1
```C
void *
mmio_map_region(physaddr_t pa, size_t size)
{
        static uintptr_t base = MMIOBASE;

        assert(pa % PGSIZE == 0);
        size = ROUNDUP(size, PGSIZE);
        if (base + size > MMIOLIM) {
                panic("Allocation exceeds MMIOLIM: %x", base + size);
        }
        boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
        void *ret_base = (void*)base;
        base += size;
        return ret_base;
}
```
## Exercise 2
_Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S?_  
Because `entry.S` is linked to have addresses above KERNBASE, it contains the macro `#define RELOC(x) ((x) - KERNBASE)` in order to translate the addresses generated by the linker (which are meant to be virtual addresses) to physical addresses (load addresses), where the data is actually stored. For example `movl    $(RELOC(entry_pgdir)), %eax` is required to use the `RELOC` macro because we don't want to load the "virtual" address of `entry_pgdir` into %eax but rather the physical (loaded) address. So this `RELOC` macro is useful for "calculating" the physical addresses of the data defined inside the file itself. A similar concept exists in in `mpentry.S` where instead we need to use `MPBOOTPHYS` in order to refer to addresses inside `mpentry.S` itself. Notice that we'd still use `RELOC` inside `mpentry.S` for things that are defined outside of `mpentry.S` such as `entry_pgdir`. If we were to omit it, we'd get virtual addresses while the AP CPU has still not enabled paging. This would cause things to fail.

## Exercise 3
_Modify mem_init_mp() (in kern/pmap.c) to map per-CPU stacks starting at KSTACKTOP, as shown in inc/memlayout.h. The size of each stack is KSTKSIZE bytes plus KSTKGAP bytes of unmapped guard pages._    

Here is the implementation:
```C
static void
mem_init_mp(void)
{
        for (int i = 0; i < NCPU; i++) {
                uintptr_t stacktop = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
                boot_map_region(kern_pgdir,
                                stacktop - KSTKSIZE,
                                KSTKSIZE,
                                PADDR(percpu_kstacks[i]),
                                PTE_W);
        }


}
```

This made me confused me at first because this implies that we'd be overriding the way we set up the kernel stack prior to SMP support:
```C
        //////////////////////////////////////////////////////////////////////
        // Use the physical memory that 'bootstack' refers to as the kernel
        // stack.  The kernel stack grows down from virtual address KSTACKTOP.
        // We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
        // to be the kernel stack, but break this into two pieces:
        //     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
        //     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
        //       the kernel overflows its stack, it will fault rather than
        //       overwrite memory.  Known as a "guard page".
        //     Permissions: kernel RW, user NONE

        uintptr_t backed_stack = KSTACKTOP-KSTKSIZE;
        boot_map_region(kern_pgdir, backed_stack, KSTKSIZE, PADDR(bootstack), PTE_W);
```
I was wondering about the following: if we override this mapping inside our new `mem_init_mp` function, once we load the new `kern_pgdir`, wouldn't we mess CPU 0's stack (which starts at KSTACKTOP-KSTKSIZE)? 
After all, `mem_init_mp` makes CPU 0's stack now be mapped to  `percpu_kstacks[0]` (a region currently contains no data) instead of being mapped to `bootstack`, which is where our current stack resides.

The reason why it won't mess it up is because at the time that the new `kern_pgdir` is loaded, the stack pointer actually points to a virtual address outside of `[KSTACKTOP-KSTKSIZE, KSTACKTOP)`, and hence we are safe to modify that mapping. We can confirm this in gdb where we observe that the value of the stack pointer is above `KERNBASE`:
```
(gdb) b pmap.c:248
Breakpoint 1 at 0xf0101e50: file kern/pmap.c, line 248.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0xf0101e50 <mem_init+505>:   mov    -0x10(%ebp),%eax

Breakpoint 1, mem_init () at kern/pmap.c:248
248             lcr0(cr0);
(gdb) i r esp
esp            0xf0124fa0       0xf0124fa0
```
The new kernel stack will be located in `[KSTACKTOP-KSTKSIZE, KSTACKTOP)` only once we switch back from user space to kernel space.

### Memory map
```
/*
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig -------->  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ---->  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ---->  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 */
```
